/**
 * A simple script to read in a JSON file generated by Firefox's bookmarks
 * manager and output the bookmarks into a nicely formatted HTML file.
 */

// Dependencies:
var fs = require('fs'),
    path = require('path'),
    Q = require('q'),
    Handlebars = require('handlebars');

// "Constants":
var FOLDER_TEMPLATE_FILE = __dirname + '/templates/folder.handlebars',
    BOOKMARK_TEMPLATE_FILE = __dirname + '/templates/bookmark.handlebars',
    LAYOUT_TEMPLATE_FILE = __dirname + '/templates/layout.handlebars',
    CSS_FILE = __dirname + '/styles.css',
    JS_FILE = __dirname + '/collapse.js';

// Data variables:
var bookmarksJsonFile = process.argv[2],
    outputFile = process.argv[3],
    startFolder = process.argv[4],
    bookmarks,
    outputStream,
    folderTemplate,
    bookmarkTemplate,
    layoutTemplate;

// Handlebars helper for rendering folder children.
Handlebars.registerHelper('renderChild', function(child) {
  if (child.type == 'text/x-moz-place') {
    return new Handlebars.SafeString('<li>' + bookmarkTemplate(child) + '</li>');
  }
  if (child.type == 'text/x-moz-place-container') {
    return new Handlebars.SafeString('<li>' + folderTemplate(child) + '</li>');
  }
  return '';
});

// If bookmarks JSON file is a relative path, resolve it to an absolute one.
if (bookmarksJsonFile.charAt(0) != '/') {
  bookmarksJsonFile = path.resolve(__dirname, bookmarksJsonFile);
}
// Check if the bookmarks JSON file exists.
(function() {
  var deferred = Q.defer();
  fs.exists(bookmarksJsonFile, deferred.resolve);
  return deferred.promise;
})()
.then(function(exists) {
  if (!exists) {
    throw new Error('Bookmarks JSON file not found.');
  }
  // Read JSON data from file.
  return Q.nfcall(fs.readFile, bookmarksJsonFile);
})
.then(function(data) {
  bookmarks = JSON.parse(data);
  // If user specified a start folder, reduce bookmarks to contents of that folder.
  if (startFolder) {
    bookmarks = getFolder(startFolder, bookmarks);
    if (!bookmarks) {
      throw new Error('The specified start folder was not found.');
    }
  }
  // Read in folder and bookmark templates, as well as CSS and JS.
  return [
    Q.nfcall(fs.readFile, FOLDER_TEMPLATE_FILE),
    Q.nfcall(fs.readFile, BOOKMARK_TEMPLATE_FILE),
    Q.nfcall(fs.readFile, LAYOUT_TEMPLATE_FILE),
    Q.nfcall(fs.readFile, CSS_FILE),
    Q.nfcall(fs.readFile, JS_FILE)
  ];
}, function(error) {
  throw new Error('Unable to read Bookmarks JSON file. Please check its permissions.');
})
.spread(function(folderTemplateContents, bookmarkTemplateContents, layoutTemplateContents, css, js) {
  // Compile templates.
  folderTemplate = Handlebars.compile(folderTemplateContents.toString());
  bookmarkTemplate = Handlebars.compile(bookmarkTemplateContents.toString());
  layoutTemplate = Handlebars.compile(layoutTemplateContents.toString());
  Handlebars.registerPartial('folder', folderTemplate);
  // Recursively render bookmarks.
  var renderedBookmarks = layoutTemplate({content: bookmarks, css: css, js: js});
  return Q.nfcall(fs.writeFile, outputFile, renderedBookmarks);
})
// On failure, print the error message.
.fail(function(error) {
  console.log('Error: ' + error.message);
});

/**
 * Recursively searches for a folder.
 *
 * @param string|array folder
 *   An array, or string with the structure "parent-folder/child-folder",
 *   representing the path to the desired folder.
 * @param object contents
 *   The object with children to search through.
 *
 * @return object|bool
 *   Folder object if it was found, or false if not.
 */
function getFolder(folder, contents) {
  if (typeof folder === 'string') {
    folder = folder.split('/');
  }
  var currentFolder = folder[0];
  var foundFolder = false;
  var children = contents.children;
  folder = folder.slice(1);
  for (var i = 0, length = children.length; i < length; i++) {
    if (children[i].type == 'text/x-moz-place-container' && children[i].title == currentFolder) {
      foundFolder = children[i];
      break;
    }
  }
  if (folder.length > 0 && foundFolder) {
    return getFolder(folder, foundFolder);
  }
  return foundFolder;
}
